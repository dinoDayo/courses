# Notes from lectures

### Sections 1-2 notes... (deploy-single-server)
- Syntax for resource declaration: `resource "PROVIDER_TYPE" "NAME" { [CONFIG..] }`
- `terraform plan`: dry-run cmd to validate a given terraform plan
- `terraform apply`: applies logic in a given terraform plan.
- `terraform destroy`: removes resources created from a terraform apply execution

### Section 3 notes... (Deploy; from single servers to multiple)
- Interpolation is useful for accessing variable values, resource outputs, and resource attributes. The sytanx is simple; `${provider_resource-type.identifier.attribute}`, for example: `${aws_instance.my_ec2.id}`.
- A more verbose example:
    - Given a resource declaration: `resource "aws_security_group" "webserver_sg" { Ingress{...} Egress{...} }`
    - Referencing the resource declaration via interpolation: `resource "aws_instance" "My-Webserver" { vpc_security_group_ids = ["${aws_security_group.webserver_sg.id}"]}`
- `user_data` is an Amazon Web Service resource that allows us to execute an installation script on an ec2 instance once the instance is up and running.
- Variables / Resources declared in any `filename.tf` files can be referenced using `interpolation`.
- Resource values in terraform can be parameterized to simplify the process of sharing and configuring different terraform scripts.
- Variables can be declared with the following syntax: `variable <variable_name> { default = <default-variable-value> }`
- Interpolation can be used on generated variables as well, not just for user-defined resources. 
- For example: `ec2-server-name-${count.index}` will increment the name of your ec2 instances as each instance is created, limited by the number set in the count variable.
- Terraform can also print attribute values for generated AWS resources as they are created, for example, the public IP of each ec2 instance that we create with our terraform code. See `output.tf` in this lab for an example of this feature.
- NOTE: the launch config declaration syntac is slightly different from other resources..tbd why.... normal resources: `resource "blah" "blah" { blah }` vs. launch configs: `resource blah "blah" { blah }`....tags and other fields can sometimes be declared without an `=` sign in situations like this...tbd on the reasons behind these idiosycrasies. 

### Section 4 notes... (Terraform key concepts)
- Interpolation is a very powerful tool for accessing and referencing variables and resources generated by terraform. For example:
    - `"${var.ami}"`
    - `"${var.region}"`
    - `"${self.private_ip}"`
    - `"${var.MAP[KEY]}"` ie. `"${var.ami[us-east-1]}"`
    - `"${var.LIST}"` ie. `"${var.subnets}"`
    - `"${MODULE.NAME.OUPUT}"` ie. `"${module.webservers.DNS_name_elb}"`
    - `"${path.TYPE}"` ie. `"${path.module}"`
    - `"${terraform.FIELD}"` ie. `"${terraform.workspace}"` 
    - See the terraform website for a comprehensive list of attributes that can be accessed via interpolation.
- You can also use ternary operators via interpolation to set environment variables. For example:
    - `subnet = "${var.env_type == "production" ? var.prod_subnet : var.dev_subnet}"`
- There are many built-in functions that are very helpful. See docs for more percise definitions. Fucntion examples:
    - `file(path)`: provides a filename for terraform consumption. ie. `file("user_data.sh")` 
    - `concat(list1, list2, list3)`: concatenates values into a single parameter.
    - `Format(format, args)`: formats string using provided format.
    - `Join(delim, list)`: joins lists into single parameter. 
- Terraform also supports a `data resource` template, where a collection of configurations and variable declarations can be defined in a separate file and refernced from a separate terraform script.
- Some important Terraform commands:
    - `terraform show`: outputs human-readable version of the terraform state file 
    - `terraform validate`: validates the syntax of your terraform code
    - `terraform plan`: shows a preview of the resources that are going to be created/edited/removed with your code
    - `terraform apply`: applies plan defined in terraform plan
    - `terraform apply-auto-approve`: applies plan defined in terraform plan in non-interactive manner
    - `terraform destroy`: destroys terraform managed infrastructure
    - `terraform fmt`: formats your terraform code to reflect standard formatting practices
    - `terraform taint`: manually marks a resource for recreation meaning a given resource will be removed and recreated upon every deploy.
    - `terraform get`: Downloads and installs the latest module versions for your terraform code
    - `terraform graph`: creates a dependency graph that can be used to view resource dependencies.
    - `terraform <cmd> -target=<taget-resource>`: allows users to apply terraform commands to only one resource as opposed to all of them
    - `terraform state`: provides current state of the terraform resources.
    - `terraform output`: view output variables associated with terraform script
- Declaring input variables:
```
variable "<variable_name>" {
    description = "variable description for developer support"
    type = list | map | string | number | bool | set | object | tuple | etc.
    default = [] | {} | "" | etc.
    }
```
- Invalid input variable names:
    - `Source`
    - `Locals`
    - `Version`
    - `Providers`
    - `Count`
    - `For_each`
    - `Lifecycle`
    - `Depends_on`
- Declaring output values:
```
output "output_var_name" {
    description = "output description for developer support"
    value = "${resource_type.resource_name.resource_attr}"
    sensitive = true | false --> determines whether or not output var will be accessible to users without access to the .tfstate file
    depends_on = [] --> a method for explicitly defining depnendencies between modules
    }
```
- Terraform Readonly remote state: a method for configuring readonly remote state storage for terraform. This allows separate terraform stacks to reference the same resource using the output variables stored in readonly remote state storage. See lab 06-deploy-readonly-remote-storage-stage for a functional example of this.
    - ie. `"${data.terraform_remote_state.global_sg.outputs.global_sg_id}"`: provides access to the global security group id
    - NOTE: I can only get this to work with terraform version 1.5.7. See the open issue explaining why this is happening [here](https://github.com/hashicorp/terraform/issues/34223).
    - Install steps for terraform version 1.5.7:
        - install terraform version [here](https://releases.hashicorp.com/terraform/)
        -  
- 
 




