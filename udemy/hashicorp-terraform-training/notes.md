# Notes from lectures

### Sections 1-2 notes... (deploy-single-server)
- Syntax for resource declaration: `resource "PROVIDER_TYPE" "NAME" { [CONFIG..] }`
- `terraform plan`: dry-run cmd to validate a given terraform plan
- `terraform apply`: applies logic in a given terraform plan.
- `terraform destroy`: removes resources created from a terraform apply execution

### Section 3 notes... (Deploy; from single servers to multiple)
- Interpolation is useful for accessing variable values, resource outputs, and resource attributes. The sytanx is simple; `${provider_resource-type.identifier.attribute}`, for example: `${aws_instance.my_ec2.id}`.
- A more verbose example:
    - Given a resource declaration: `resource "aws_security_group" "webserver_sg" { Ingress{...} Egress{...} }`
    - Referencing the resource declaration via interpolation: `resource "aws_instance" "My-Webserver" { vpc_security_group_ids = ["${aws_security_group.webserver_sg.id}"]}`
- `user_data` is an Amazon Web Service resource that allows us to execute an installation script on an ec2 instance once the instance is up and running.
- Variables / Resources declared in any `filename.tf` files can be referenced using `interpolation`.
- Resource values in terraform can be parameterized to simplify the process of sharing and configuring different terraform scripts.
- Variables can be declared with the following syntax: `variable <variable_name> { default = <default-variable-value> }`
- Interpolation can be used on generated variables as well, not just for user-defined resources. 
- For example: `ec2-server-name-${count.index}` will increment the name of your ec2 instances as each instance is created, limited by the number set in the count variable.
- Terraform can also print attribute values for generated AWS resources as they are created, for example, the public IP of each ec2 instance that we create with our terraform code. See `output.tf` in this lab for an example of this feature.
- NOTE: the launch config declaration syntac is slightly different from other resources..tbd why.... normal resources: `resource "blah" "blah" { blah }` vs. launch configs: `resource blah "blah" { blah }`....tags and other fields can sometimes be declared without an `=` sign in situations like this...tbd on the reasons behind these idiosycrasies. 

### Sections 4-5 notes... (Terraform key concepts)
- Interpolation is a very powerful tool for accessing and referencing variables and resources generated by terraform. For example:
    - `"${var.ami}"`
    - `"${var.region}"`
    - `"${self.private_ip}"`
    - `"${var.MAP[KEY]}"` ie. `"${var.ami[us-east-1]}"`
    - `"${var.LIST}"` ie. `"${var.subnets}"`
    - `"${MODULE.NAME.OUPUT}"` ie. `"${module.webservers.DNS_name_elb}"`
    - `"${path.TYPE}"` ie. `"${path.module}"`
    - `"${terraform.FIELD}"` ie. `"${terraform.workspace}"` 
    - See the terraform website for a comprehensive list of attributes that can be accessed via interpolation.
- You can also use ternary operators via interpolation to set environment variables. For example:
    - `subnet = "${var.env_type == "production" ? var.prod_subnet : var.dev_subnet}"`
- There are many built-in functions that are very helpful. See docs for more percise definitions. Fucntion examples:
    - `file(path)`: provides a filename for terraform consumption. ie. `file("user_data.sh")` 
    - `concat(list1, list2, list3)`: concatenates values into a single parameter.
    - `Format(format, args)`: formats string using provided format.
    - `Join(delim, list)`: joins lists into single parameter. 
- Some important Terraform commands:
    - `terraform show`: outputs human-readable version of the terraform state file 
    - `terraform validate`: validates the syntax of your terraform code. Good to run after `terraform plan`
    - `terraform plan`: shows a preview of the resources that are going to be created/edited/removed with your code
    - `terraform apply`: applies plan defined in terraform plan
    - `terraform apply-auto-approve`: applies plan defined in terraform plan in non-interactive manner
    - `terraform destroy`: destroys terraform managed infrastructure
    - `terraform fmt`: formats your terraform code to reflect standard formatting practices
    - `terraform taint`: manually marks a resource for recreation meaning a given resource will be removed and recreated upon every deploy.
    - `terraform get`: Downloads and installs the latest module versions for your terraform code. Good to run if a local module is replaced with one hosted in a git repo.
    - `terraform graph`: creates a dependency graph that can be used to view resource dependencies.
    - `terraform <cmd> -target=<taget-resource>`: allows users to apply terraform commands to only one resource as opposed to all of them
    - `terraform state`: provides current state of the terraform resources.
    - `terraform output`: view output variables associated with terraform script
- Declaring input variables:
```
variable "<variable_name>" {
    description = "variable description for developer support"
    type = list | map | string | number | bool | set | object | tuple | etc.
    default = [] | {} | "" | etc.
    }
```
- Invalid input variable names:
    - `Source`
    - `Locals`
    - `Version`
    - `Providers`
    - `Count`
    - `For_each`
    - `Lifecycle`
    - `Depends_on`
- Syntax for declaring output values:
```
output "output_var_name" {
    description = "output description for developer support"
    value = "${resource_type.resource_name.resource_attr}"
    sensitive = true | false --> determines whether or not output var will be accessible to users without access to the .tfstate file
    depends_on = [] --> a method for explicitly defining depnendencies between modules
    }
```
- Syntax for accessing module output values:
```
"${module.module_name.OUTPUT_VARIABLE_NAME}"
```

### Section 6 notes... (Terraform state)
- Terraform Readonly remote state: a method for configuring readonly remote state storage for terraform. This allows separate terraform stacks to reference the same resource using the output variables stored in readonly remote state storage. See lab 06-deploy-readonly-remote-storage-stage for a functional example of this.
    - ie. `"${data.terraform_remote_state.global_sg.outputs.global_sg_id}"`: provides access to the global security group id
    - NOTE: Any/all resources referenced in the `backend` clause must exist BEFORE they are referenced.
- Terraform data sources allow data to be fetched or computer for use elsewhere in a given terraform configuration. They are declared using the following syntax:
```
data "Provider_type" "Name" {
    arguments...
}
```
- Terraform's `data source` templates enable a collection of configurations and variable declarations to be defined in a separate file and refernced from a separate terraform script. All data sources can be queried with filters to, for example, support the retrieval of the most recent version of the data source. The data provided in the data source declaration is what is used to filter the data objects returned. The aws-related data sources supported by terraform include but are not limited to the following list:
    - `aws_availability_zone`
        - fields: `Name, Region, Name_suffix, state, Zone_id`
    - `aws_availability_zones`
        - fields: `Names, Zone_ids`
    - `aws_billing_service_account`
        - fields: `Names, Zone_ids`
    - `aws_arn`
        - fields: `Partition, Service, Region, account, resource`
    - `aws_caller_identity`
        - fields: `Account_id, Arn, User_id`
    - `aws_ip_ranges`
        - fields: `Cidr_blocks, Ipv6_cidr_blocks, Create_date, Sync_token`
    - `aws_partition`
        - fields: `Partition, Dns_suffix`
    - `aws_region`
        - fields: `Name, Endpoint, description`
    - `aws_iam_policy_document`
        - fields: `json`
- Terraform Module GOTCHA's:
    - always parametrize the hard-coded values in your modules as variable declarations in a separate file, then reference them using interpolation. This will ensure your configurations are flexible for a given module depending on your desired use-case.
    - when declaring resources, always prioritize separate declarations over inline declarations. The following aws resources can be declared inline OR as separate resources, but it is still recommended to declare them as separate resources whenever possible:
        - `Security Group rules` ie: A `security_group.tf` file would have the following structure:
            - `security_group_declaration`
            - `security_group_ingress_rule_1_declaration`
            - `security_group_egress_rule_1_declaration`
            - `security_group_egress_rule_2_declaration`
        - `Route Tables`
        - `Network ACL`
        - `Elastic Load Balancer (ELB)`
- Terraform Module Versioning:
    - In order to manage multiple versions of a given module in terraform, git tags can be used. The following example url show how version `v0.0.8` of a given module can be retrieved from github as a terraform module using git tags;
        - Module source url format: `{git::}{https://githubRepoUrl.git//}{modulePath/within/repo?}{gitTagVersion}`
        - Module source url example: `git::https://github.com/cloudiac18/ultimate-terraform-course-for-devops.git//Section-05-modules/modules/webservers-elb-asg?ref=v0.0.8`
- Terraform State:
    - We must always use separate deploys for each of our different Terraform environments (dev, stg, prd) in order to ensure deploys to the different environments don't affect each other. This is a concern because by default, terraform stores its state in a file called `terraform.state`. This file is locked while it is being edited and cannot be changed until the lock is released. If the dev, stg, and prd environments all shared the same `terraform.tfstate` file, deploys to each of those environments would be dependent on each other, as opposed to allowing them to be managed independinly.
    - Terraform Remote Storage is another useful method of protecting the `terraform.state` file from corruption or unintended updates/rollbacks. The protection of the `terraform.state` file is achieved by storing it in a remote location, (ie. aws s3), that is accessible to all developers. This forces each developer to incorperate the most recent changes of their collaborators into their code before they can continue to make edits, thereby protecting the `terraform.state` file from unwanted race conditions.
    - Terraform State Locking protects your `terraform.state` file from being corrupted by preventing multiple simultaneous updates to the same `terraform.state` file. This can be achieved through the default Hashicorp-defined functionality provided with terraform, a user-defined CI/CD job configuration (ie. via Jenkins or CircleCI), or through a custom user-defined update configuration that leverages `DynamoDB` tables. The lab for `Section-06-terraform-state/tf-state-locking` in this repo contains an example of the user-defined dynamoDB implementation. 
- Example terraform remote storage declaration:
```
terraform {
    backend "s3" {
        encrypt = true
        bucket = "terraformiac-mystach-tfstate"
        key="deploy-multiple-webserver/terraform.tfstate"
        region = "us-east-1"
    }
}
```

### Section 7 notes... (Working with key AWS Services)



## Open Questions:
- General debugging; How does one get more verbose error messages when a given terraform script fails?
- For Section 05-terraform-module-basics, why am I seeing the following error when I run `terraform apply`? The error:
```
│ Error: creating Route53 Hosted Zone: InvalidVPCId: The VPC: vpc-cd8735b7 in region us-east-1 that you provided is not authorized to make the association.
│       status code: 400, request id: 2388e5f3-3ec1-4f08-82d6-b77d6353fd7f
│ 
│   with module.webservers.aws_route53_zone.main,
│   on ../../module/webservers-elb-asg/route53.tf line 1, in resource "aws_route53_zone" "main":
│    1: resource "aws_route53_zone" "main" {
```
    - **ANSWER**: This was happenning because I had a vpc_id variable declared in two places; the module and the stack where I was deploying that module. The variable value in the stack was overwriting the variable value in the module, which led to the error message pasted above.




